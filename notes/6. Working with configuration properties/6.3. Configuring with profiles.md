# Configuring with profiles
Sometimes we need to **deploy our application to different environments**, and configuration details can differ. 
We can use environment variables to configure properties in one environment over another. 
**Example**:
```bash
% export SPRING_DATASOURCE_URL=jdbc:mysql://localhost/tacocloud 
% export SPRING_DATASOURCE_USERNAME=tacouser  
% export SPRING_DATASOURCE_PASSWORD=tacopassword
```
It works, but it is inconvinient to specify more properties. Also, we may need to track changes to environment variables or to esily rollback changes. 
We will take advantage of **Spring profiles**.
- **Spring profiles** - type of a conditional configuration where different beans, configuration classes, and configuration properties are applied or ignored based on what profiles are active at run time.
- **Example:** for development and debug purposes, we want to use embedded H2 database and logging level to be set to `DEBUG`.  In production, we want to use an external MySQL database and set logging levels to `WARN`.
- It is easy to set necessary properties in development, but in case of deployed application we cannot set it without changing `application.yml`.
- We can define a proper suited for production.
## Defining profile-specific properties
- **First way** - create another YAML or properties file containing only the
properties for production.
File naming convention:  `application-{profile name}.yml or application-{profile name} .properties.` 
**Example:** we can create a file named `application-prod.yml` :
```yaml
spring:
  datasource: 
	url: jdbc:mysql://localhost/tacocloud
    username: tacouser
    password: tacopassword
    
	logging:
	  level: 
		tacos: WARN
```
- **Second way** - in YAML configration place profile specific configuration, separated by three hyphens and the `spring.profiles` to name the profile:
```yaml
logging:
  level: 
	tacos: DEBUG

--- 
spring:
  profiles: prod 

  datasource:
    url: jdbc:mysql://localhost/tacocloud
    username: tacouser
    password: tacopassword 

  logging:
	level: 
	  tacos: WARN
```
- Also, we need to activate profile when it's needed.
## Activating profiles
Include it in the list of profile names given to the  
`spring.profiles.active` property. 
- **First way.** Change in `application.yml` like this, for example:
```yaml
spring:
  profiles: 
	active:
    - prod
```
This is the worst approach, `prod` profile becomes default - no benefits from profiles.
- **Second way:** change this property as environment variable on production environment.
```bash
% export SPRING_PROFILES_ACTIVE=prod
```
- Third way: if we're running application as the JAR file, we can set command-line argument like this: 
```bash
% java -jar taco-cloud.jar --spring.profiles.active=prod
```
We can specify more than one profile!
```bash
% export SPRING_PROFILES_ACTIVE=prod,audit,ha
```
So, as in YAML:
```yaml
spring:
  profiles: 
	 active:
	 - prod
	 - audit
	 - ha
```
**Note:** if we deploy Spring Application in **Cloud Factory**, a profile named `cloud` is automatically activated. If Cloud Foundry is your produc- tion environment, you’ll want to be sure to specify production-specific properties under the cloud profile.
## Conditionally creating beans with profiles
We can set **different beans for different profiles.** 
- Default: bean is active for any active profile.
But what if we need some beans to be created only if a certain profile is active? 
- `@Profile` annotation - designate beans as being applicable to only a given profile(s).
- **Example**: we declared **CommandLineRunner** bean declared in `TacoCloudApplication` that’s used to load the embedded database with ingredient data when the application starts. **This is undesirable for production.** We can do this:
```java
@Bean  
@Profile("dev")  
public CommandLineRunner dataLoader(IngredientRepository repo,
	UserRepository userRepo, PasswordEncoder encoder) {
    
	... 
}
```
We can place a list of profiles:
```java
@Bean  
@Profile({"dev", "qa"})  
public CommandLineRunner dataLoader(IngredientRepository repo,

	UserRepository userRepo, PasswordEncoder encoder) {
        
    ... 
}
```
Or we can say: do not create this bean for profile `prod` :
```java
@Bean  
@Profile("!prod")  
public CommandLineRunner dataLoader(IngredientRepository repo,

	UserRepository userRepo, PasswordEncoder encoder) {
        
    ... 
}
```
- We can use this annotation for `@Configuration`-annotated classes. **For example:** 
```java
@Profile({"!prod", "!qa"})
@Configuration
public class DevelopmentConfig { 

	@Bean  
	public CommandLineRunner dataLoader(IngredientRepository repo,
		UserRepository userRepo, PasswordEncoder encoder) { 
		...
	} 
}
```





