# Reading and writing data with JDBC
- Mostrly for working wuth relational data, Java developers use **JDBC** and **JPA**
- Spring has JDBC support.
- Spring JDBC support is rooted in the **JdbcTemplate** class
- Spring JDBC helps to write a code without catching `SQLException` and write catch and closing connection and so on. JdbcTemplate helps.
- Code without JdbcTemplate:
```java
@Override
public Optional<Ingredient> findById(String id) { 

  Connection connection = null;
  PreparedStatement statement = null;
  ResultSet resultSet = null;
  try { 
  . connection = dataSource.getConnection();
    statement = connection.prepareStatement( 
		"select id, name, type from Ingredient where id=?");
    statement.setString(1, id);
    resultSet = statement.executeQuery();
    Ingredient ingredient = null; 
	if(resultSet.next()) {
	      ingredient = new Ingredient( 
				resultSet.getString("id"),
				resultSet.getString("name"),				
				Ingredient.Type.valueOf(resultSet.getString("type")));				
	}
	return Optional.of(ingredient);
  } 
  catch (SQLException e) { 
	 // ??? What should be done here ???
  } 
  finally { 

  if (resultSet != null) {
      try { 
		 resultSet.close();
      } catch (SQLException e) {} 

  } 
    if (statement != null) { 
		try {
	        statement.close(); 
	
		} catch (SQLException e) {}
    }
     
	if (connection != null) {
	    try { 
		 connection.close();
	    } catch (SQLException e) {} 
    }
}

    return Optional.empty();
}
```
Code with JdbcTemplate:
```java
private JdbcTemplate jdbcTemplate; 

public Optional<Ingredient> findById(String id) {
  List<Ingredient> results = jdbcTemplate.query( 

  "select id, name, type from Ingredient where id=?",
      this::mapRowToIngredient,
      id); 

  return results.size() == 0 ?
          Optional.empty() : 
	      Optional.of(results.get(0)); 

}  
private Ingredient mapRowToIngredient(ResultSet row, int rowNum)
	 throws SQLException {
  return new Ingredient( 
	row.getString("id"),  
		row.getString("name"),
		Ingredient.Type.valueOf(row.getString("type")));
}
```
## Adapting the domain for persistence
- Good to add a field that uniquely identifies the object. 
- Good idea to add a field to capture date and time that the objects are saved.
- Thanks to Lombok, we don't need to write getters and setters, but without it - we would do it.
- It is made here: [Commit](https://github.com/bozhnyukAlex/spring-in-action-project/commit/805ce5e7a19c0dc2561c5e232f12a41148263c00)
## Working with JdbcTemplate
- Set dependency for JdbcTemplate
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```
- Set dependency for H2 database
```xml
<dependency>
 	 <groupId>com.h2database</groupId>
 	 <artifactId>h2</artifactId>
 	 <scope>runtime</scope> 
</dependency>
```
- Set name to database and disable generating name randonly in `application.properties` .
```groovy
spring.datasource.generate-unique-name=false
spring.datasource.name=tacocloud
```
### Defining JDBC repositories
We will write repository that fetches and saves `Ingredient` data.
This repository will perform following operations:
-  Query for all ingredients into a collection of `Ingredient` objects
-  Query for a single `Ingredient` by its `id`
-  Save an `Ingredient` object
Interface will look like this:
```java
public interface IngredientRepository {  
    Iterable<Ingredient> findAll();  
  
	Optional<Ingredient> findById(String id);  
  
	Ingredient save(Ingredient ingredient);  
}
```
Now we will add an implementation. ([Here](https://github.com/bozhnyukAlex/spring-in-action-project/blob/92ed7dc1730c92893ed562b2c06ebbeb129f9ab9/src/main/java/tacos/data/JdbcIngredientRepository.java))
- `@Repository` - class will be automatically discovered by Spring Boot component scanning and added as a bean in the Spring application context. 
- There's only one constructor => Spring automatically injects JdbcTemplate. Spring applies autowiring of dependencies through constructor parameter. if there is more than one constructor, or we wand explicitly stated `@Autowired`  (`@Autowired` constructor vs `@Autowired` field - [link](https://odrotbohm.de/2013/11/why-field-injection-is-evil/))
- `RowMapper` - mapping each row in the result set to an object
- `query()` - accepts SQL as a query, RowMapper and final argument(s) as a list of any parameters required in query (? in query are replaced with this parameters)
### Inserting a row
 JdbcTemplateâ€™s `update()` method can be used for any query that writes or updates data in the database.
 ```java 
@Override
public Ingredient save(Ingredient ingredient) { 
	 jdbcTemplate.update(
	      "insert into Ingredient (id, name, type) values (?, ?, ?)",
	      ingredient.getId(),
	      ingredient.getName(),
	      ingredient.getType().toString()); 
	
	 return ingredient;
}
 ```
 - No need for `RowMapper`.
Now we will inject repository into `DesignTacoController`. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/blob/2768d8bcaf6bcccb88a5012154dd5f181a849232/src/main/java/tacos/web/DesignTacoController.java))
We use `findAll()` method to fetch all ingredients from the database, then filter them into distinct ingredient types, and adding them to the model. 

Then we will upgrade `IngredientByIdConverter`, inject `IngredientRepository` to it. We do not need map anymore ([code](https://github.com/bozhnyukAlex/spring-in-action-project/blob/2768d8bcaf6bcccb88a5012154dd5f181a849232/src/main/java/tacos/web/IngredientByIdConverter.java))
## Design a schema and preloading data
We will create some tables to hold information.![](/Users/Alexander.Bozhnyuk/IdeaProjects/taco-cloud/notes/images/tables.png)
- `Taco` can't exist without `Taco_Order` context.
- `Ingredient_ref` - to make a relation many-on-many between `Taco` and `Ingredient` 
- We will put a SQL that create this tables to the `schema.sql` file in the `src/main/resources` folder. When the application starts, this file will be executed automatically. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/87e6c0cf7707d23b957becae35dbbdaf7fc328d5#diff-cbcbed36c1bed4a691cc78859494682ca215586fdd348c6204aca31c3c843179))
- Also we need to preload database with some data. We will place SQL code for this in `data.sql`. This file will also be executed ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/87e6c0cf7707d23b957becae35dbbdaf7fc328d5#diff-7f148b1d99361fa9fe2a88f2009f50179de9cc7f46aea5240411c21289d2f36a)).
## Inserting data
- Now we will write repositories for persisting `Taco` and `TacoOrder` data.
- Taco and TacoOrder are parts of **aggregate relation** (TacoOrder is a root). So, Taco cannot exist outside of context of TacoOrder.
- We'll define a repository to persist `TacoOrder` objects and `Taco` in turn. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/0850346f649285159cc7c23cf24c3e717425b5d7#diff-4998d42798c1adcd2b4bb09cd92b9696a5644734c1c39cccd9ddaf7209d6976d))
- When we save `TacoOrder`, we must save `Taco` objects, that go with it. When we save `Taco` objects, we need to save object, that represents a link  between `Taco` and each `Ingredient`: `IngredientRef`. We need to create it. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/0850346f649285159cc7c23cf24c3e717425b5d7#diff-f02f3b6e9768675d39f445cc952fa4b66f234f8ee5cd7d69fc1a47c0cc47d6ce))
**Implementation**. We need to determine what ID is assigned to the order once it has been saved. `Taco_Order` has `id` with type `identity`  - database will generate value automatically. When database determines value for us, we need to get that value, so we can return it in the `TacoOrder` object  in `save()` method.
Let's look at it: ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/0850346f649285159cc7c23cf24c3e717425b5d7#diff-4998d42798c1adcd2b4bb09cd92b9696a5644734c1c39cccd9ddaf7209d6976d)).
- `PreparedStatementCreatorFactory` - describe insert query along with types of fields.
-  `setReturnGeneratedKeys(true)` - need it because we will fetch the saved order's ID to set it to the `TacoOrder` object
- We use `PreparedStatementCreator` (created with factory), passing in the values from the `TacoOrder` . 
- Also we need to set the date of order creation to a `TacoOrder` object (before executing statement!).
- Calling `update()` method - save the data, passing in `PreparedStatementCreator` and a `GeneratedKeyHolder`. After order data has been saved, `GenerateKeyHolder` will contain the  value of `id` field as assigned by database. We need to set it ti `TacoOrder` object's `id` property.  
- After order is saved, we need to saved all tacos accoring to this order!
- We have a `saveTaco()` method. It works in similar way, but after saving Tco we need call `saveIngredientRefs()` to create a row in `Ingredient_Ref` table to link the Taco row to an `Ingredient` row.
- The last thing - inject it to the `OrderController` ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/0850346f649285159cc7c23cf24c3e717425b5d7#diff-795cc38cdd43b53d9c513d36836617544584af0f3353fe47ccca416efb1535f1))
`JdbcTemplate` makes working with relational databases realy simpler than without it. But there are some challenging tasks, such as persisting domain objects in an aggregate relation.
**Spring Data JDBC** helps working with JDBC much easier.

