# Working with Spring Data JDBC
**Spring Data** - project, which contains many subprojects. There are some popular: 
- Spring Data JDBC—JDBC persistence against a relational database 
- Spring Data JPA—JPA persistence against a relational database  
- Spring Data MongoDB—Persistence to a Mongo document database 
- Spring Data Neo4j—Persistence to a Neo4j graph database
- Spring Data Redis—Persistence to a Redis key-value store  
- Spring Data Cassandra—Persistence to a Cassandra column store database
We will apply Spring Data JDBC.
With it we can automatically create repositories.
## Adding Spring Data JDBC to the build
It is available as a starter dependency. We can add it.
```xml
<dependency>  
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
```
And we can remove old JdbcTemplate dependency. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/5e2bba46b99b77a388c05c3db38ff84293c6d31e#diff-9c5fb3d1b7e3b0f54bc5c4182965c4fe1f9023d449017cece3005d3f90e8e4d8))
## Defining repository interfaces
- Spring Data can automatically generate implementations of repositories.
- We need to extend repository Interfaces from Spring Data by ours.
- `IngredientRepository` can extend `Repository`  interface 
- `Repository` interface is parameterized. First parameter - type of object to be persisted in repository, second - type of persisitent object's ID field.
- More often it is more convinient to extend `CrudRepository`, because it already has many methods, including ours. `IngredientRepository` and `OrderRepository` will extend this. ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/9d439043e25043ce74d375349432cb0aa3c32eb9#diff-a8af74c750eb71a10246e5a8a0049598d3c42069b816b608bac9d96fcc9318bd))
- Implementations? No need to write them! Spring Data generates implementations on the fly. We just need to inject them, and that's all! We can delete old implementations ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/9d439043e25043ce74d375349432cb0aa3c32eb9#diff-a8af74c750eb71a10246e5a8a0049598d3c42069b816b608bac9d96fcc9318bd)).
## Annotating the domain class for persistence
We need to annotate our domain classes so tha Spring Data JDBC will know how to persist them.
- `@Table` - optional annotation. By default, object is mapped to a table based on the domain class name. For `TacoOrder` - `Taco_Order` name. We can specify name name of table in braces:  `@Table("Taco_Cloud_Order")` 
- `@Id` - property with this annotation is the identity for a table.
- `@Column(name)` - map name of property to column `name`  of table. By default all names will be mapped automatically (deliveryName -> delivery_name).
- We will apply `@Table` and `@Column` to the `TacoOrder`, `Taco` and `Ingredient`, `Ingredient_Ref`.([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/ce241ce615135ca825771ec022916b1706d2677c))
## Preloading data with CommandLineRunner
- **Before**: preloading data in `data.sql`. It will work also there. But we can use more flexible way.
- Spring Boot offers two functional interfaces for executing logic when an application starts up: `CommandLineRunner` and `ApplicationRunner`. They both have method run(), that are invoked after the application context and all beans are wired up, but before anything else.
- We can create them as a beans in configuration class ([code]).
- Differrence between interfaces - parameter of `run()` method. `CommandLineRunner` - `String` vararg args. `ApplicationRunner` - `ApplicationArgument` parameter, that offers methods for accesssing the arguments as parsed components of the command line. In first case we need to scan array to find needed command argument. But in second we can do this:
```java
public ApplicationRunner dataLoader(IngredientRepository repo) { 
	return args -> {
		List<String> version = args.getOptionValues("version"); 
		... 
	};
}
```
**This approach is more flexible:** it works with different databases: even non-relational.