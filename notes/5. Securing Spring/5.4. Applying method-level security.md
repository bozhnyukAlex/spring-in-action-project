# Applying method-level security
 Sometimes it’s better to verify that the user is authenticated and has been granted adequate authority **at the point where the secured action will be performed.**
 **Example:** service class has a method for clearing out all orders from the database. 
 Something like that with injected OrderRepository:
 ```java
public void deleteAllOrders() {
  orderRepository.deleteAll(); 
}
 ```
 Suppose we have a controller, that calls deleteAllOrders() method as the result of a POST request:
 ```java
  

@Controller
@RequestMapping("/admin")
public class AdminController { 

	private OrderAdminService adminService; 

	public AdminController(OrderAdminService adminService) { 
		this.adminService = adminService;
	}

	@PostMapping("/deleteOrders")
	public String deleteAllOrders() {
	    adminService.deleteAllOrders(); 
		return "redirect:/admin";
	} 

}
 ```
 Would be a good idea to upgrade `SecurityConfig` as folows to ensure that only authorized users are allowed to perform that `POST` request:
 ```java
.authorizeRequests()
  ... 

 .antMatchers(HttpMethod.POST, "/admin/**")
          .access("hasRole('ADMIN')") 
....
 ```
 - This prevents any unauthorized user from making a `POST` request to `/admin/deleteOrders` that would result in all orders disappearing from the database.
 - But what if other controller uses `deleteAllOrders()` method? We would need more matches. 
 - `@PreAuthorize` annotation - takes a SpEL expression, and it this expression will be evaluated to `false` method will not allowed. Here is checking that the user has the `ROLE_ADMIN` priviledge.
 - If the `@PreAuthorize` blocks the csall. then Spring Security’s `AccessDeniedException` will be thrown. It is unchecked, but we don't need to catch it. unless we don't need to apply some custom behavior.
 - If this exception is left uncaught, it will bubble up and eventually be caught by **Spring Security’s filters and handled accordingly**, either with an HTTP 403 page or perhaps by redirecting to the login page if the user is unauthenticated.
 - For `@PreAuthorize` to work, you’ll need to enable global method security. Annotation  `@EnableGlobalMethodSecurity` on security configuration class.
 - Also we have a `@PostAuthorize` method. Works almost the same way, but expression is evaluated after method is invoked and returned. This allows the expression to consider the return value of the method in deciding whether to permit the method invocation. 
 - **Example**: 
 ```java
@PostAuthorize("hasRole('ADMIN') || " + "returnObject.user.username == authentication.name")
public TacoOrder getOrder(long id) {
  ... 

}
 ```
In this case, the `returnObject` in the `TacoOrder` returned from the method. If its user property has a username that is equal to the authentication’s name property, then it will be allowed. To know that, the method will need to be executed so that it can return the `TacoOrder` object for consideration.