# Configuring authentication
We will configure authentification in out application.
Firstly, we'll write configuration class:
```java
package tacos.security;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; 
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig { 

  @Bean
  public PasswordEncoder passwordEncoder() { 
	  return new BCryptPasswordEncoder();
  } 

}
```
This configuration does not much. It declares PasswordEncoder bean. We will use it when creating new users and when authenticating users at login. There are more of such encoders:
- `BCryptPasswordEncoder`—Applies bcrypt strong hashing encryption
- `NoOpPasswordEncoder`—Applies no encoding 
- `Pbkdf2PasswordEncoder`—Applies PBKDF2 encryption  
- `SCryptPasswordEncoder`—Applies Scrypt hashing encryption
- `StandardPasswordEncoder`—Applies SHA-256 hashing encryption
 **Important**: password in the database is never decoded. When user enters password, it is encoded with the same algorithm, and then it is compared with the encoded password in the database. Comparison is performed by `PasswordEncoder`'s `matches()` method().
 **Now we need to configure a user store that can handle more than one user.**
 We need to declare a UserDetailsService bean. This interface looks like this:
 ```java 
public interface UserDetailsService { 

 UserDetails loadUserByUsername(String username) throws
     UsernameNotFoundException; 

}
 ``` 
 The `loadUserByUsername()`  method accepts a username and uses it to look up a UserDetails object. If no user can be found for the given username, then it will throw a `UsernameNotFoundException`.
 Spring Security offers some implementations of `UserDetailsService` :
 - An in-memory user store 
 - A JDBC user store  
 - An LDAP user store
## In-memory user details service
We can keep user information **in memory**. This is good approach, if we don't have many users and none of them are likely to change. So, we can define them as a part of security configuration. 
```java
@Bean  
public UserDetailsService userDetailsService(PasswordEncoder encoder) {

   List<UserDetails> usersList = new ArrayList<>();
   usersList.add(new User( 
	  "buzz", encoder.encode("password"),  
		   Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"))));

   usersList.add(new User(
      "woody", encoder.encode("password"), 
		Arrays.asList(new SimpleGrantedAuthority("ROLE_USER")))); 
   return new InMemoryUserDetailsManager(usersList);

}
```
- We create two users, each with username, password, and list if of authorities.
- This is a good approach for testing, but it doesn't allow to edit users easily. 
- We want customers to be able to register with the applciation and manage their own accounts. We need to create our own implemetation of `UserDetailsService`.
## Customizing user authentication
We will persist data about users using Spring Data JPA. Firstly, let's create domain and repository.
### Defining the user domain and persistence
Let's create domain class `User`, which contain not only username and password, but their full name, address, and phone number ([code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/2c8c4ca68d689806425687771ef7b30e1890aa04#diff-01a89da376f537d044993ccdffca58bab2756fe8e603173ff01f995c3ea437cc)).
- This is not the same `User` class as the `User` class we used in previous section.
- `User` implements `UserDetails` interface from Spring Security. It provides some essential information to the framework, such as what authoriries are granted or whether the user's account is enables.
-  `getAuthorities()` method returns a collection of authorities granted to the user. In our `User` we simply return collection with one `ROLE_USER` authority.
- `is*` methods indicate whether the user account is enabled, locked or expired. We return `true` here: no need to disable users.
Now we will create a repository interface for Users:
```java
package tacos.data;  
import org.springframework.data.repository.CrudRepository; 
import tacos.User;

public interface UserRepository extends CrudRepository<User, Long> { User
	findByUsername(String username);
}
```
- We do it as always but also added one method: `findByUsername(String username)`
### Creating a user details service
UserDetailsService defines only loadUserByUsername() method. So, this functional interface can be implemented as a lambda in configuration class: 
```java
@Bean  
public UserDetailsService userDetailsService(UserRepository userRepo) {
	 return username -> {
	    User user = userRepo.findByUsername(username);
	    if (user != null) return user; 
	
		throw new UsernameNotFoundException("User '" + username + "' not found"); 
	 };
}
```
-  The `loadByUsername()` method has one simple rule: it must never return null. Therefore, if the call to `findByUsername()` returns `null`, the lambda will throw a `UsernameNotFoundException` (which is defined by Spring Security). Otherwise, the `User` that was found will be returned.
**Next**: we need to create a registration page for Taco Cloud to let users register with the application.
### Registering users
We need to use **Spring MVC** to create `Controller` and other things related to the registration.
First: create a `RegistrationController` : [code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/2c8c4ca68d689806425687771ef7b30e1890aa04#diff-35ff7c5a85cf2e7ee2ebb937c28e39c1e1f7570597dfc52413b7667eef4c8f19) 
- `@Controller` - designate it as controller and mark it for component scanning.
- `@RequestMapping("/register")` - handle requests with `"/register"` path.
- GET request will be handled by `registerForm()` method, simply returns view name.
Let's create such a view: [code](https://github.com/bozhnyukAlex/spring-in-action-project/commit/2c8c4ca68d689806425687771ef7b30e1890aa04#diff-9dd8e7a301b8e2e1ccfbda45f1d774e9d1f8a6de6f8c6125a7a18ff0adf293ef) 
- When the form is submitted, method handles the **HTTPS `POST` request**. Form fields will be bound to a `RegistrationForm` object by Spring MVC and passed into the `processRegistration()` method for processing. Here is a `RegistrationForm` class:
```java
@Data  
public class RegistrationForm {  
  
    private String username;  
	private String password;  
	private String fullname;  
	private String street;  
	private String city;  
	private String state;  
	private String zip;  
	private String phone;  
	
	public User toUser(PasswordEncoder passwordEncoder) { 
		return new User(  
            username, passwordEncoder.encode(password),  
			fullname, street, city, state, zip, phone);  
	}  
}
```
- Mostly, basic **Lombok** class with a handful of properties. 
- Method `toUser()` uses those properties to create a new `User`  object, which is what `processingRegistration()` will save with injected `UserRepository`.
- `toUser()` uses `PasswordEncoder` to encode the password before saving it to the database. User details service will be able to authenticate against that encoded password. 
- This is exact same `PasswordEncoder` bean we declared earlier. 
By default, all requests require authentication, but it means that we can go even to the registration page without being prompted to log in! We will look at how web requests are intecepted and secured and fix this situation.