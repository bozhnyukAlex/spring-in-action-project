# Knowing your user
Sometimes, it's not enough to simply know, that your users have logged in and their permissions. **It's important to also know who they are to tailor their experience.**
**Example**: `OrderController`. When you create `TacoOrder` object, it would be good to prepopuldate `TacoOrder` with thee user's name and address. Or, you need to associate the `TacoOrder` entity with the `User` that created the order.
We can add new property to the TacoOrder class:
```java
@Data
@Entity
@Table(name="Taco_Order")
public class TacoOrder implements Serializable { 

...

	@ManyToOne
	private User user; 
... 
}
```
- `@ManyToOne`:  indicates that an order belongs to a sin- gle user and, conversely, that a user may have many orders.
- We need to modify `processOrder()` in `OrderController` method to determine who the euthneticated user is and call setUser() on `TacoOrder` object.
**We have several ways to do that:**
- Inject a `java.security.Principal` object into the controller method.
- Inject an `org.springframework.security.core.Authentication` object into the controller method .
- Use `org.springframework.security.core.context.SecurityContextHolder `to get at the security context. 
- Inject an `@AuthenticationPrincipal` annotated method parameter. 
(`@AuthenticationPrincipal` is from Spring Security’s `org.springframework .security.core.annotation` package.)
With first way: use a principal name to look up to the user from `UserRepository`:
```java
@PostMapping  
public String processOrder(@Valid TacoOrder order, Errors errors,
			 SessionStatus sessionStatus, Principal principal) { 

	User user = userRepository.findByUsername(principal.getName());
	order.setUser(user); 
	... 
}
```
It litters code  that’s otherwise unrelated to security with security code.
Second way: with `Authentication` object.
```java
 

@PostMapping  
public String processOrder(@Valid TacoOrder order, Errors errors, 
						   SessionStatus sessionStatus,
						   Authentication authentication) { 

  ...
  User user = (User) authentication.getPrincipal();
  order.setUser(user); 
  ... 
}
```
 With the `Authentication` in hand, you can call `getPrincipal()` to get the principal object which, in this case, is a User. Note that getPrincipal() returns a` java.util .Object`, so you need to cast it to `User`.
 Perhaps the cleanest solution: accept a `User` object in `processOrder()` but annotate it with `@AuthenticationPrincipal` so that it will be the authentication’s principal:
 ```java
  

@PostMapping  
public String processOrder(@Valid TacoOrder order, Errors errors,
						   SessionStatus sessionStatus,
						   @AuthenticationPrincipal User user) { 

 if (errors.hasErrors()) {
    return "orderForm"; 

 }
 order.setUser(user); 

 orderRepo.save(order);
 sessionStatus.setComplete(); 

 return "redirect:/";
}
 ```
 -  `@AuthenticationPrincipal` is that it doesn’t require a cast (as with Authentication)
 -  It limits the security-specific code to the annotation itself
 There is also another way:  obtain an `Authentication` object from the security context and then request its principal like this:
 ```java
Authentication authentication = 
	SecurityContextHolder.getContext().getAuthentication();
User user = (User) authentication.getPrincipal();
 ```
 - Many secirity-specific code
 - **Advantage:** it can be used anywhere in the application, not just in a controller’s handler methods. This makes it suitable for use in lower levels of the code.